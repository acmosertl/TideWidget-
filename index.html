<div id="madhabam-tide-widget" style="max-width:300px;">
</div>

<script>
/* TIDE WIDGET - STANDALONE (Final Compact Dynamic UI - Responsiveness Fixed) */
(function(){
    // API Endpoints and Default Location (Kolkata)
    const API_OM = 'https://api.open-meteo.com/v1/forecast';
    const API_IP = 'https://ipapi.co/json/';
    const DEFAULT = { lat:22.57, lng:88.36, source:'স্থির স্থানাঙ্ক', city:'কলকাতা' };
    const $ = id => document.getElementById(id);
    
    // Fallback Data
    const FALLBACK_DATA = {
        tide_anchor_fallback: '20:30', 
    };

    // Global STATE object to hold the fetched tide times
    let STATE = { lat: DEFAULT.lat, lng: DEFAULT.lng, source: DEFAULT.source, city: DEFAULT.city, tides:[] };
    let updateUIInterval = null; 
    let updateDataInterval = null; 
    
    // --- Localization and Formatting ---
    function formatToBengali(dateInput, isTime = false, showSeconds = false) {
        if (!dateInput) return '—';
        try {
            const date = (dateInput instanceof Date) ? dateInput : new Date(dateInput);
            if (isNaN(date)) return '—';
            
            const options = { timeZone: 'Asia/Kolkata' };
            
            if (isTime) {
                options.hour = '2-digit'; 
                options.minute = '2-digit';
                if (showSeconds) options.second = '2-digit'; 
                options.hour12 = true;
                return date.toLocaleTimeString('bn-BD', options);
            }
            options.day = '2-digit';
            options.month = '2-digit';
            options.year = 'numeric';
            return date.toLocaleDateString('bn-BD', options).replace(/\//g, '-');
        } catch (e) {
            return '—';
        }
    }
    
    function parseBengaliTime(timeStr, dateContext) {
        try {
            const parts = timeStr.split(' ');
            if (parts.length !== 2) return null;

            const [timePart, ampm] = parts;
            let [h, m] = timePart.split(':').map(Number);
            
            if (ampm === 'PM' && h !== 12) h += 12;
            if (ampm === 'AM' && h === 12) h = 0;
            
            let date = dateContext || new Date();
            date.setHours(h, m, 0, 0);
            return date;
        } catch (e) {
            return null;
        }
    }

    // --- Dynamic SVG Helpers ---
    function createWaveSVG() {
        const ns = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(ns, 'svg');
        svg.setAttribute('width', '24'); svg.setAttribute('height', '24'); svg.setAttribute('viewBox', '0 0 24 24');

        const style = document.createElementNS(ns, 'style');
        style.textContent = `
            .wave { fill: none; stroke: #FFF; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; animation: wave-motion 2s linear infinite alternate; }
            @keyframes wave-motion { 0% { transform: translateY(0px); } 100% { transform: translateY(-2px); } }
        `;
        svg.appendChild(style);
        const path1 = document.createElementNS(ns, 'path'); path1.setAttribute('class', 'wave'); path1.setAttribute('d', 'M2 12s2-2 4-2 4 2 4 2 2-2 4-2 4 2 4 2'); svg.appendChild(path1);
        const path2 = document.createElementNS(ns, 'path'); path2.setAttribute('class', 'wave'); path2.setAttribute('d', 'M2 16s2-2 4-2 4 2 4 2 2-2 4-2 4 2 4 2'); path2.style.animationDelay = '-1s'; svg.appendChild(path2);

        return svg.outerHTML;
    }
    
    function createGlowArrow(direction, size = '1.1em') {
        const arrow = direction === 'up' ? '▲' : '▼';
        const color = direction === 'up' ? '#32CD32' : '#FF4500'; 
        const shadow = `0 0 5px ${color}, 0 0 10px ${color}`;

        return `<span style="font-size: ${size}; color: ${color}; text-shadow: ${shadow}; margin-left: 5px; position: relative; top: ${direction === 'up' ? '-2px' : '2px'};">${arrow}</span>`;
    }

    // --- Tide Data Approximation ---
    function approxTides(baseTime){
        // ... (Approximation logic remains the same)
        let base = new Date();
        if(baseTime && baseTime.includes('T')) base = new Date(baseTime);
        else if(baseTime) { 
             const d=new Date(); 
             const [h, m] = baseTime.split(':').map(Number);
             base = new Date(d.getFullYear(), d.getMonth(), d.getDate(), h, m, 0);
        }
        
        const gap = (6 * 60 + 12) * 60000; 
        const out = [];
        const types = ['উচ্চ জোয়ার', 'নিম্ন ভাটা', 'উচ্চ জোয়ার', 'নিম্ন ভাটা']; 
        
        for(let i=0; i < 4; i++){
            let t = new Date(base.getTime() + i * gap); 
            out.push({ 
                type: types[i], 
                time: formatToBengali(t, true),
                level: (i % 2 === 0) ? 'high' : 'low', 
                timestamp: t.getTime() 
            }); 
        }
        
        return out.sort((a, b) => a.timestamp - b.timestamp);
    }
    
    // --- Current Water Level Calculation (FIXED and IMPROVED) ---
    function getDynamicLevelInfo(tides) {
        if (!tides || tides.length === 0) return { level: 50, direction: 'static', nextEventIndex: -1 };
        
        const now = new Date().getTime();
        let closestPastEvent = null;
        let nextEvent = null;
        let nextEventIndex = -1;

        // Find the closest past event and the immediate next event
        for(let i = 0; i < tides.length; i++) {
            if (tides[i].timestamp <= now) {
                closestPastEvent = tides[i];
                nextEvent = tides[i+1];
                nextEventIndex = i+1;
            } else if (!nextEvent) {
                nextEvent = tides[i];
                nextEventIndex = i;
            }
        }
        
        // Handle wrap-around (if the list has ended, the next event is the first one tomorrow)
        if (!nextEvent) {
            nextEvent = tides[0]; 
            closestPastEvent = tides[tides.length - 1]; 
            nextEventIndex = 0;
            
            // Re-calculate timestamps for next day context
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            
            nextEvent.timestamp = parseBengaliTime(nextEvent.time, tomorrow).getTime();
            
            // Check if the closest past event is still too old (e.g., from yesterday)
            const yesterdayLimit = now - (6 * 60 * 60 * 1000); // Only consider events within the last 6 hours as relevant start
            if(closestPastEvent.timestamp < yesterdayLimit) {
                 // If the list wrapped, assume the event before the last one was the start of the current cycle yesterday.
                 // This is complex, so let's use a simpler heuristic for the previous event's level if past event is too old.
                 // We will skip interpolation and just show the level approaching the next event.
                 closestPastEvent = null; 
            }
        }
        
        const levelStart = closestPastEvent && closestPastEvent.level === 'high' ? 95 : 5;
        const levelEnd = nextEvent && nextEvent.level === 'high' ? 95 : 5;
        
        let currentLevel = 50; 
        let direction = 'static'; 

        // Linear Interpolation
        if (closestPastEvent && nextEvent && nextEvent.timestamp > closestPastEvent.timestamp) {
            const timeDiff = nextEvent.timestamp - closestPastEvent.timestamp;
            const levelDiff = levelEnd - levelStart;
            const timeElapsed = now - closestPastEvent.timestamp;

            // Ensure we are within the current cycle's time window
            if(timeElapsed >= 0 && timeElapsed <= timeDiff) {
                currentLevel = levelStart + (levelDiff * (timeElapsed / timeDiff));
            } else if (timeElapsed > timeDiff) {
                 // Should be exactly at the end level if interpolation missed
                 currentLevel = levelEnd;
            } else {
                currentLevel = levelStart;
            }

            
            if (levelStart === 95 && levelEnd === 5) {
                direction = 'down'; 
            } else if (levelStart === 5 && levelEnd === 95) {
                direction = 'up'; 
            }
        } else if (nextEvent) {
             // If closestPastEvent is null (i.e., we only found nextEvent), assume we are heading towards it
             // For visual responsiveness, we'll simplify and show the direction towards the next event.
             currentLevel = levelEnd; // A heuristic: set level near the destination to make the direction clear.
             direction = nextEvent.level === 'high' ? 'up' : 'down';
        }
        
        currentLevel = Math.max(5, Math.min(95, currentLevel)); 

        return { 
            level: Math.round(currentLevel), 
            direction: direction, 
            nextEventIndex: nextEventIndex 
        }; 
    }

    // --- Build Functions (for initial render and live updates) ---
    
    function buildTideList(tides, dynamicLevelInfo) {
        let tideListHTML = '';
        const nextEventIndex = dynamicLevelInfo.nextEventIndex;
        const currentDirection = dynamicLevelInfo.direction;

        if (tides && tides.length) {
            tides.forEach((t, index) => {
                const isHighlight = index === nextEventIndex;
                const highlightClass = isHighlight ? 'highlight' : '';
                
                // Show arrow direction on the type name for visual aid
                const arrowIndicator = isHighlight && currentDirection !== 'static' ? createGlowArrow(currentDirection, '0.9em') : '';
                
                tideListHTML += `
                    <div class="tide-item-compact ${highlightClass}">
                        <span class="tide-label-group">
                            <div class="tide-icon-svg">${createWaveSVG()}</div>
                            <div class="tide-text-stack">
                                <span class="tide-type-value">${t.type}${arrowIndicator}</span>
                                <span class="tide-time-value">${t.time || '—'}</span>
                            </div>
                        </span>
                    </div>
                `;
            });
        } else {
             tideListHTML = `<div class="tide-item-compact"><span>তথ্য পাওয়া যায়নি।</span><span>—</span></div>`;
        }
        return tideListHTML;
    }
    
    function buildWidget(data) {
        
        const currentDateBengali = formatToBengali(new Date(), false);
        const dynamicLevelInfo = getDynamicLevelInfo(data.tides);
        
        // --- 1. CSS Styles (Remains the same for the most part) ---
        const css = `
            <style>
                #madhabam-tide-widget *{ 
                    box-sizing: border-box; 
                    font-family: 'Noto Sans Bengali', 'Kalpurush', 'SolaimanLipi', sans-serif !important; 
                    line-height: 1.1; 
                    color: #333; 
                }
                .tide-panel { 
                    background-color: #006f7a; 
                    color: white; 
                    border-radius: 12px; 
                    padding: 15px; 
                    margin-bottom: 15px; 
                    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15); 
                    display: flex; 
                    gap: 10px; 
                    height: auto; 
                    min-height: 350px;
                    overflow: hidden; 
                }
                .tide-panel * { color: white !important; }
                
                .tide-content { 
                    flex-grow: 1; 
                    display: flex;
                    flex-direction: column;
                    justify-content: space-between; 
                    min-width: 0; 
                }
                
                .tide-header-section { 
                    display: flex;
                    justify-content: space-between;
                    align-items: flex-end;
                    margin-bottom: 10px; 
                }
                .tide-header-title { 
                    font-weight: 900; 
                    font-size: 1.45em; 
                    color: #FFEB3B !important; 
                }
                
                .tide-events-list { 
                    flex-grow: 1; 
                    margin-bottom: 10px; 
                }

                .tide-item-compact { 
                    display: flex; 
                    justify-content: space-between; 
                    align-items: center; 
                    font-size: 1.0em; 
                    padding: 5px 0; 
                    margin: 4px 0;
                    border-bottom: 1px dotted rgba(255, 255, 255, 0.1);
                    transition: all 0.3s;
                    position: relative;
                }
                
                .tide-label-group { 
                    display: flex; 
                    align-items: center; 
                    gap: 5px; 
                    font-weight: 600; 
                    white-space: nowrap; 
                }
                .tide-text-stack {
                    display: flex;
                    flex-direction: column;
                    align-items: flex-start;
                    line-height: 1;
                    padding-left: 2px;
                }
                .tide-type-value {
                    font-weight: 700;
                    font-size: 1.1em;
                }
                .tide-time-value { 
                    font-weight: 800; 
                    font-size: 1.05em; 
                    color: #FFEB3B !important; 
                    white-space: nowrap; 
                    margin-top: 2px;
                } 
                
                .tide-item-compact.highlight {
                     background-color: rgba(255, 255, 255, 0.2); 
                     border-radius: 4px;
                     padding: 6px;
                     margin: 4px -6px;
                     box-shadow: 0 0 8px rgba(255, 235, 59, 0.5); 
                }

                .footer-tags-section {
                    padding-top: 10px;
                    border-top: 1px solid rgba(255, 255, 255, 0.4);
                }
                .tide-date-footer {
                    font-size: 0.9em;
                    font-weight: 700; 
                    color: #A9E4FF !important;
                    margin-bottom: 5px;
                }
                .location-time-tag { 
                    text-align: left; 
                    font-size: 0.9em; 
                    font-weight: 600; 
                }
                .location-time-tag span { font-weight: 800; color: #e6c300 !important; }
                
                .level-indicator-container {
                    width: 50px; 
                    min-width: 50px;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    padding-top: 10px;
                    padding-bottom: 10px;
                }
                .level-indicator-bar {
                    flex-grow: 1; 
                    width: 35px; 
                    border: 3px solid #FFFFFF;
                    border-radius: 12px;
                    background-color: rgba(255, 255, 255, 0.2);
                    overflow: hidden;
                    position: relative;
                }
                .water-fill {
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    width: 100%;
                    background: linear-gradient(to top, #A9E4FF 0%, #00BFFF 100%); 
                    transition: height 0.5s linear; /* Linear transition for smoother flow */
                    border-top: 3px solid #FFFFFF;
                }
                .water-level-text {
                    position: absolute;
                    top: 50%; 
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-size: 0.8em;
                    font-weight: 900;
                    color: #006f7a !important; 
                    z-index: 10;
                    transition: opacity 0.5s;
                }
            </style>
        `;
        
        const initialLocalTime = formatToBengali(new Date(), true, true);
        const panelArrow = dynamicLevelInfo.direction !== 'static' ? createGlowArrow(dynamicLevelInfo.direction, '1.4em') : '';

        const tideHTML = `
            <div class="tide-panel">
                <div class="tide-content">
                    <div class="tide-header-section">
                        <div class="tide-header-title">জোয়ার-ভাটা</div>
                        <div class="level-indicator-label" style="text-align: right; margin-right: 5px;">
                            <span id="panel-arrow-indicator">${panelArrow}</span><br>
                            <span style="font-size: 0.7em;">বর্তমান জলস্তর</span>
                        </div>
                    </div>
                    
                    <div class="tide-events-list" id="tide-events-list">${buildTideList(data.tides, dynamicLevelInfo)}</div>
                    
                    <div class="footer-tags-section">
                        <div class="tide-date-footer">আজ: ${currentDateBengali}</div>
                        <div class="location-time-tag">
                            স্থান: <span>${data.city}</span> | স্থানীয় সময়: <span id="local-time-live">${initialLocalTime}</span>
                        </div>
                    </div>
                </div>
                
                <div class="level-indicator-container">
                    
                    <div class="level-indicator-bar">
                        <div class="water-level-text" id="water-level-text">${dynamicLevelInfo.level}%</div>
                        <div class="water-fill" id="water-fill" style="height: ${dynamicLevelInfo.level}%;">
                            </div>
                    </div>
                </div>
            </div>
        `;
        
        return css + tideHTML;
    }
    
    // --- UI Update Function (Runs very frequently for smooth movement) ---
    function updateLiveUI() {
        // Only run if tides data is loaded
        if (STATE.tides.length === 0) return;
        
        const timeElement = $('local-time-live');
        if (timeElement) {
            timeElement.textContent = formatToBengali(new Date(), true, true);
        }

        const fillElement = $('water-fill');
        const textElement = $('water-level-text');
        const listElement = $('tide-events-list');
        const panelArrowElement = $('panel-arrow-indicator');
        
        if (fillElement && textElement && listElement && panelArrowElement) {
            const dynamicLevelInfo = getDynamicLevelInfo(STATE.tides);
            
            // Update percentage and height
            fillElement.style.height = `${dynamicLevelInfo.level}%`;
            textElement.textContent = `${dynamicLevelInfo.level}%`;
            
            // Rebuild the list structure to update highlighting and individual arrows
            listElement.innerHTML = buildTideList(STATE.tides, dynamicLevelInfo);
            
            // Update the main panel arrow indicator
            panelArrowElement.innerHTML = dynamicLevelInfo.direction !== 'static' ? createGlowArrow(dynamicLevelInfo.direction, '1.4em') : '';
        }
    }

    // --- Main Loader Function ---
    async function loadAllData() {
        // 1. Clear intervals
        if (updateDataInterval) clearInterval(updateDataInterval);
        if (updateUIInterval) clearInterval(updateUIInterval);
        
        // 2. Fetch Coordinates (Only once)
        const coords = await loadCoordinates();
        STATE.lat = coords.lat;
        STATE.lng = coords.lng;
        STATE.source = coords.source;
        STATE.city = coords.city;
        
        // 3. Fetch Tide Anchor (Moonrise)
        let raw_moonrise = null;
        try {
            const r2 = await fetch(API_OM + `?latitude=${STATE.lat}&longitude=${STATE.lng}&daily=moonrise&timezone=auto`);
            const j2 = r2.ok ? await r2.json() : {};
            if(j2.daily && j2.daily.moonrise && j2.daily.moonrise.length && j2.daily.moonrise[0] && j2.daily.moonrise[0] !== null){
                raw_moonrise = j2.daily.moonrise[0];
            } else {
                raw_moonrise = FALLBACK_DATA.tide_anchor_fallback;
            }
        } catch(e) {
            raw_moonrise = FALLBACK_DATA.tide_anchor_fallback;
        }

        // 4. Approximate Tides
        STATE.tides = approxTides(raw_moonrise || new Date()); 
        
        // 5. Initial Full Render
        const targetElement = $('madhabam-tide-widget');
        if (targetElement) { 
            targetElement.innerHTML = buildWidget(STATE); 
        }
        
        // 6. Start the continuous UI update intervals (Crucial for responsiveness)
        updateUIInterval = setInterval(updateLiveUI, 100); 
        
        // 7. Set the main data refresh interval (every 30 minutes)
        updateDataInterval = setInterval(loadAllData, 1800000); 
    }

    // Initial call
    loadAllData();
})();
</script>
